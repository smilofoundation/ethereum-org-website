(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{191:function(e,o,a){"use strict";a.r(o);var t=a(0),s=Object(t.a)({},(function(){var e=this,o=e.$createElement,a=e._self._c||o;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"ibft-consensus-overview"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ibft-consensus-overview","aria-hidden":"true"}},[e._v("↳")]),e._v(" IBFT Consensus Overview")]),e._v(" "),a("h2",{attrs:{id:"introduction"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#introduction","aria-hidden":"true"}},[e._v("↳")]),e._v(" Introduction")]),e._v(" "),a("p",[e._v("Istanbul Byzantine Fault Tolerant (IBFT) consensus is inspired by Castro-Liskov 99 "),a("a",{attrs:{href:"http://pmg.csail.mit.edu/papers/osdi99.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("paper"),a("OutboundLink")],1),e._v(". IBFT inherits from the original PBFT by using a 3-phase consensus, "),a("code",[e._v("PRE-PREPARE")]),e._v(", "),a("code",[e._v("PREPARE")]),e._v(" and "),a("code",[e._v("COMMIT")]),e._v(". The system can tolerate at most "),a("code",[e._v("F")]),e._v(" faulty nodes in a "),a("code",[e._v("N")]),e._v(" validator network, where "),a("code",[e._v("N = 3F + 1")]),e._v(".")]),e._v(" "),a("h2",{attrs:{id:"implementation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#implementation","aria-hidden":"true"}},[e._v("↳")]),e._v(" Implementation")]),e._v(" "),a("h3",{attrs:{id:"terminology"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#terminology","aria-hidden":"true"}},[e._v("↳")]),e._v(" Terminology")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("Validator")]),e._v(": Block validation participant.")]),e._v(" "),a("li",[a("code",[e._v("Proposer")]),e._v(": A block validation participant that is chosen to propose block in a consensus round.")]),e._v(" "),a("li",[a("code",[e._v("Round")]),e._v(": Consensus round. A round starts with the proposer creating a block proposal and ends with a block commitment or round change.")]),e._v(" "),a("li",[a("code",[e._v("Proposal")]),e._v(": New block generation proposal which is undergoing consensus processing.")]),e._v(" "),a("li",[a("code",[e._v("Sequence")]),e._v(": Sequence number of a proposal. A sequence number should be greater than all previous sequence numbers. Currently each proposed block height is its associated sequence number.")]),e._v(" "),a("li",[a("code",[e._v("Backlog")]),e._v(": The storage to keep future consensus messages.")]),e._v(" "),a("li",[a("code",[e._v("Round state")]),e._v(": Consensus messages of a specific sequence and round, including pre-prepare message, prepare message, and commit message.")]),e._v(" "),a("li",[a("code",[e._v("Consensus proof")]),e._v(": The commitment signatures of a block that can prove the block has gone through the consensus process.")]),e._v(" "),a("li",[a("code",[e._v("Snapshot")]),e._v(": The validator voting state from last epoch.")])]),e._v(" "),a("h3",{attrs:{id:"consensus"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#consensus","aria-hidden":"true"}},[e._v("↳")]),e._v(" Consensus")]),e._v(" "),a("p",[e._v("Istanbul BFT Consensus protocol begins at Round "),a("code",[e._v("0")]),e._v(" with the validators picking a proposer from themselves in a round robin fashion. The proposer will then propose a new block proposal and broadcast it along with the "),a("code",[e._v("PRE-PREPARE")]),e._v(" message. Upon receiving the "),a("code",[e._v("PRE-PREPARE")]),e._v(" message from the proposer, other validators validate the incoming proposal and enter the state of "),a("code",[e._v("PRE-PREPARED")]),e._v(" and broadcast "),a("code",[e._v("PREPARE")]),e._v(" message. This step is to make sure all validators are working on the same sequence and on the same round. When "),a("code",[e._v("ceil(2N/3)")]),e._v(" of "),a("code",[e._v("PREPARE")]),e._v(" messages is received by the validator from other validators, the validator switches to the state of "),a("code",[e._v("PREPARED")]),e._v(" and broadcasts "),a("code",[e._v("COMMIT")]),e._v(" message. This step is to inform other validators that it accepts the proposed block and is going to insert the block to the chain. Lastly, validators wait for "),a("code",[e._v("ceil(2N/3)")]),e._v(" of "),a("code",[e._v("COMMIT")]),e._v(" messages to enter "),a("code",[e._v("COMMITTED")]),e._v(" state and then append the block to the chain.")]),e._v(" "),a("p",[e._v("Blocks in Istanbul BFT protocol are final, which means that there are no forks and any valid block must be somewhere in the main chain. To prevent a faulty node from generating a totally different chain from the main chain, each validator appends "),a("code",[e._v("ceil(2N/3)")]),e._v(" of received "),a("code",[e._v("COMMIT")]),e._v(" signatures to "),a("code",[e._v("extraData")]),e._v(" field in the header before inserting it into the chain. Thus all blocks are self-verifiable. However, the dynamic "),a("code",[e._v("extraData")]),e._v(" would cause an issue on block hash calculation. Since the same block from different validators can have different set of "),a("code",[e._v("COMMIT")]),e._v(" signatures, the same block can have different block hashes as well. To solve this, we calculate the block hash by excluding the "),a("code",[e._v("COMMIT")]),e._v(" signatures part. Therefore, we can still keep the block/block hash consistency as well as put the consensus proof in the block header.")]),e._v(" "),a("h4",{attrs:{id:"consensus-states"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#consensus-states","aria-hidden":"true"}},[e._v("↳")]),e._v(" Consensus States")]),e._v(" "),a("p",[e._v("Istanbul BFT is a state machine replication algorithm. Each validator maintains a state machine replica in order to reach block consensus. Various states in IBFT consensus are,")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("NEW ROUND")]),e._v(": Proposer to send new block proposal. Validators wait for "),a("code",[e._v("PRE-PREPARE")]),e._v(" message.")]),e._v(" "),a("li",[a("code",[e._v("PRE-PREPARED")]),e._v(": A validator has received "),a("code",[e._v("PRE-PREPARE")]),e._v(" message and broadcasts "),a("code",[e._v("PREPARE")]),e._v(" message. Then it waits for "),a("code",[e._v("ceil(2N/3)")]),e._v(" of "),a("code",[e._v("PREPARE")]),e._v(" or "),a("code",[e._v("COMMIT")]),e._v(" messages.")]),e._v(" "),a("li",[a("code",[e._v("PREPARED")]),e._v(": A validator has received "),a("code",[e._v("ceil(2N/3)")]),e._v(" of "),a("code",[e._v("PREPARE")]),e._v(" messages and broadcasts "),a("code",[e._v("COMMIT")]),e._v(" messages. Then it waits for "),a("code",[e._v("ceil(2N/3)")]),e._v(" of "),a("code",[e._v("COMMIT")]),e._v(" messages.")]),e._v(" "),a("li",[a("code",[e._v("COMMITTED")]),e._v(": A validator has received "),a("code",[e._v("ceil(2N/3)")]),e._v(" of "),a("code",[e._v("COMMIT")]),e._v(" messages and is able to insert the proposed block into the blockchain.")]),e._v(" "),a("li",[a("code",[e._v("FINAL COMMITTED")]),e._v(": A new block is successfully inserted into the blockchain and the validator is ready for the next round.")]),e._v(" "),a("li",[a("code",[e._v("ROUND CHANGE")]),e._v(": A validator is waiting for "),a("code",[e._v("ceil(2N/3)")]),e._v(" of "),a("code",[e._v("ROUND CHANGE")]),e._v(" messages on the same proposed round number.")])]),e._v(" "),a("p",[a("strong",[e._v("State Transitions")]),e._v(":\n"),a("img",{attrs:{src:"images/IBFTStateTransition.png",alt:"State Transitions"}})]),e._v(" "),a("ul",[a("li",[a("code",[e._v("NEW ROUND")]),e._v(" -> "),a("code",[e._v("PRE-PREPARED")]),e._v(":\n"),a("ul",[a("li",[a("strong",[e._v("Proposer")]),e._v(" collects transactions from txpool.")]),e._v(" "),a("li",[a("strong",[e._v("Proposer")]),e._v(" generates a block proposal and broadcasts it to validators. It then enters the "),a("code",[e._v("PRE-PREPARED")]),e._v(" state.")]),e._v(" "),a("li",[e._v("Each "),a("strong",[e._v("validator")]),e._v(" enters "),a("code",[e._v("PRE-PREPARED")]),e._v(" upon receiving the "),a("code",[e._v("PRE-PREPARE")]),e._v(" message with the following conditions:\n"),a("ul",[a("li",[e._v("Block proposal is from the valid proposer.")]),e._v(" "),a("li",[e._v("Block header is valid.")]),e._v(" "),a("li",[e._v("Block proposal's sequence and round match the "),a("strong",[e._v("validator")]),e._v("'s state.")])])]),e._v(" "),a("li",[a("strong",[e._v("Validator")]),e._v(" broadcasts "),a("code",[e._v("PREPARE")]),e._v(" message to other validators.")])])]),e._v(" "),a("li",[a("code",[e._v("PRE-PREPARED")]),e._v(" -> "),a("code",[e._v("PREPARED")]),e._v(":\n"),a("ul",[a("li",[e._v("Validator receives "),a("code",[e._v("ceil(2N/3)")]),e._v(" of valid "),a("code",[e._v("PREPARE")]),e._v(" messages to enter "),a("code",[e._v("PREPARED")]),e._v(" state. Valid messages conform to the following conditions:\n"),a("ul",[a("li",[e._v("Matched sequence and round.")]),e._v(" "),a("li",[e._v("Matched block hash.")]),e._v(" "),a("li",[e._v("Messages are from known validators.")])])]),e._v(" "),a("li",[e._v("Validator broadcasts "),a("code",[e._v("COMMIT")]),e._v(" message upon entering "),a("code",[e._v("PREPARED")]),e._v(" state.")])])]),e._v(" "),a("li",[a("code",[e._v("PREPARED")]),e._v(" -> "),a("code",[e._v("COMMITTED")]),e._v(":\n"),a("ul",[a("li",[a("strong",[e._v("Validator")]),e._v(" receives "),a("code",[e._v("ceil(2N/3)")]),e._v(" of valid "),a("code",[e._v("COMMIT")]),e._v(" messages to enter "),a("code",[e._v("COMMITTED")]),e._v(" state. Valid messages conform to the following conditions:\n"),a("ul",[a("li",[e._v("Matched sequence and round.")]),e._v(" "),a("li",[e._v("Matched block hash.")]),e._v(" "),a("li",[e._v("Messages are from known validators.")])])])])]),e._v(" "),a("li",[a("code",[e._v("COMMITTED")]),e._v(" -> "),a("code",[e._v("FINAL COMMITTED")]),e._v(":\n"),a("ul",[a("li",[a("strong",[e._v("Validator")]),e._v(" appends "),a("code",[e._v("ceil(2N/3)")]),e._v(" commitment signatures to "),a("code",[e._v("extraData")]),e._v(" and tries to insert the block into the blockchain.")]),e._v(" "),a("li",[a("strong",[e._v("Validator")]),e._v(" enters "),a("code",[e._v("FINAL COMMITTED")]),e._v(" state when insertion succeeds.")])])]),e._v(" "),a("li",[a("code",[e._v("FINAL COMMITTED")]),e._v(" -> "),a("code",[e._v("NEW ROUND")]),e._v(":\n"),a("ul",[a("li",[a("strong",[e._v("Validators")]),e._v(" pick a new "),a("strong",[e._v("proposer")]),e._v(" and begin a new round timer.")])])])]),e._v(" "),a("h4",{attrs:{id:"round-change-flow"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#round-change-flow","aria-hidden":"true"}},[e._v("↳")]),e._v(" Round change flow")]),e._v(" "),a("ul",[a("li",[e._v("There are three conditions that would trigger "),a("code",[e._v("ROUND CHANGE")]),e._v(":\n"),a("ul",[a("li",[e._v("Round change timer expires.")]),e._v(" "),a("li",[e._v("Invalid "),a("code",[e._v("PREPREPARE")]),e._v(" message.")]),e._v(" "),a("li",[e._v("Block insertion fails.")])])]),e._v(" "),a("li",[e._v("When a validator notices that one of the above conditions applies, it broadcasts a "),a("code",[e._v("ROUND CHANGE")]),e._v(" message along with the proposed round number and waits for "),a("code",[e._v("ROUND CHANGE")]),e._v(" messages from other validators. The proposed round number is selected based on following condition:\n"),a("ul",[a("li",[e._v("If the validator has received "),a("code",[e._v("ROUND CHANGE")]),e._v(" messages from its peers, it picks the largest round number which has "),a("code",[e._v("F + 1")]),e._v(" of "),a("code",[e._v("ROUND CHANGE")]),e._v(" messages.")]),e._v(" "),a("li",[e._v("Otherwise, it picks "),a("code",[e._v("1 + current round number")]),e._v(" as the proposed round number.")])])]),e._v(" "),a("li",[e._v("Whenever a validator receives "),a("code",[e._v("F + 1")]),e._v(" of "),a("code",[e._v("ROUND CHANGE")]),e._v(" messages on the same proposed round number, it compares the received one with its own. If the received is larger, the validator broadcasts "),a("code",[e._v("ROUND CHANGE")]),e._v(" message again with the received number.")]),e._v(" "),a("li",[e._v("Upon receiving "),a("code",[e._v("ceil(2N/3)")]),e._v(" of "),a("code",[e._v("ROUND CHANGE")]),e._v(" messages on the same proposed round number, the "),a("strong",[e._v("validator")]),e._v(" exits the round change loop, calculates the new "),a("strong",[e._v("proposer")]),e._v(", and then enters "),a("code",[e._v("NEW ROUND")]),e._v(" state.")]),e._v(" "),a("li",[e._v("Another condition that a validator jumps out of round change loop is when it receives verified block(s) through peer synchronization.")])]),e._v(" "),a("h4",{attrs:{id:"proposer-selection"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#proposer-selection","aria-hidden":"true"}},[e._v("↳")]),e._v(" Proposer selection")]),e._v(" "),a("p",[e._v("Currently we support two policies: "),a("strong",[e._v("round robin")]),e._v(" and "),a("strong",[e._v("sticky proposer")]),e._v(".")]),e._v(" "),a("ul",[a("li",[e._v("Round robin: Round robin is the default proposer selection policy. In this setting proposer will change in every block and round change.")]),e._v(" "),a("li",[e._v("Sticky proposer: in a sticky proposer setting, proposer will change only when a round change happens.")])]),e._v(" "),a("h4",{attrs:{id:"validator-list-voting"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#validator-list-voting","aria-hidden":"true"}},[e._v("↳")]),e._v(" Validator list voting")]),e._v(" "),a("p",[e._v("Istanbul BFT uses a similar validator voting mechanism as Clique and copies most of the content from Clique "),a("a",{attrs:{href:"https://github.com/ethereum/EIPs/issues/225",target:"_blank",rel:"noopener noreferrer"}},[e._v("EIP"),a("OutboundLink")],1),e._v(". Every epoch transaction resets the validator voting, meaning any pending votes for adding/removing a validator are reset.")]),e._v(" "),a("p",[e._v("For all transactions blocks:")]),e._v(" "),a("ul",[a("li",[e._v("Proposer can cast one vote to propose a change to the validators list.")]),e._v(" "),a("li",[e._v("Only the latest proposal per target beneficiary is kept from a single validator.")]),e._v(" "),a("li",[e._v("Votes are tallied live as the chain progresses (concurrent proposals allowed).")]),e._v(" "),a("li",[e._v("Proposals reaching majority consensus "),a("code",[e._v("VALIDATOR_LIMIT")]),e._v(" come into effect immediately.")]),e._v(" "),a("li",[e._v("Invalid proposals are not to be penalized for client implementation simplicity.")]),e._v(" "),a("li",[e._v("A proposal coming into effect entails discarding all pending votes for that proposal (both for and against) and starts with a clean slate.")])]),e._v(" "),a("h4",{attrs:{id:"future-message-and-backlog"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#future-message-and-backlog","aria-hidden":"true"}},[e._v("↳")]),e._v(" Future message and backlog")]),e._v(" "),a("p",[e._v("In an asynchronous network environment, one may receive future messages which cannot be processed in the current state. For example, a validator can receive "),a("code",[e._v("COMMIT")]),e._v(" messages on "),a("code",[e._v("NEW ROUND")]),e._v('. We call this kind of message a "future message." When a validator receives a future message, it will put the message into its '),a("strong",[e._v("backlog")]),e._v(" and try to process later whenever possible.")]),e._v(" "),a("h4",{attrs:{id:"constants"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#constants","aria-hidden":"true"}},[e._v("↳")]),e._v(" Constants")]),e._v(" "),a("p",[e._v("Istanbul BFT define the following constants")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("EPOCH_LENGTH")]),e._v(": Default: 30000 blocks. Number of blocks after which to checkpoint and reset the pending votes.")]),e._v(" "),a("li",[a("code",[e._v("REQUEST_TIMEOUT")]),e._v(": Timeout for each consensus round before firing a round change in millisecond.")]),e._v(" "),a("li",[a("code",[e._v("BLOCK_PERIOD")]),e._v(": Minimum timestamp difference in seconds between two consecutive blocks.")]),e._v(" "),a("li",[a("code",[e._v("PROPOSER_POLICY")]),e._v(": Proposer selection policy, defaults to round robin.")]),e._v(" "),a("li",[a("code",[e._v("ISTANBUL_DIGEST")]),e._v(": Fixed magic number "),a("code",[e._v("0x63746963616c2062797a616e74696e65206661756c7420746f6c6572616e6365")]),e._v(" of "),a("code",[e._v("mixDigest")]),e._v(" in block header for Istanbul block identification.")]),e._v(" "),a("li",[a("code",[e._v("DEFAULT_DIFFICULTY")]),e._v(": Default block difficulty, which is set to "),a("code",[e._v("0x0000000000000001")]),e._v(".")]),e._v(" "),a("li",[a("code",[e._v("EXTRA_VANITY")]),e._v(": Fixed number of extra-data prefix bytes reserved for proposer vanity.\n"),a("ul",[a("li",[e._v("Suggested "),a("code",[e._v("32")]),e._v(" bytes to retain the current extra-data allowance and/or use.")])])]),e._v(" "),a("li",[a("code",[e._v("NONCE_AUTH")]),e._v(": Magic nonce number "),a("code",[e._v("0xffffffffffffffff")]),e._v(" to vote on adding a validator.")]),e._v(" "),a("li",[a("code",[e._v("NONCE_DROP")]),e._v(": Magic nonce number "),a("code",[e._v("0x0000000000000000")]),e._v(" to vote on removing a validator.")]),e._v(" "),a("li",[a("code",[e._v("UNCLE_HASH")]),e._v(": Always "),a("code",[e._v("Keccak256(RLP([]))")]),e._v(" as uncles are meaningless outside of PoW.")]),e._v(" "),a("li",[a("code",[e._v("PREPREPARE_MSG_CODE")]),e._v(": Fixed number "),a("code",[e._v("0")]),e._v(". Message code for "),a("code",[e._v("PREPREPARE")]),e._v(" message.")]),e._v(" "),a("li",[a("code",[e._v("PREPARE_MSG_CODE")]),e._v(": Fixed number "),a("code",[e._v("1")]),e._v(". Message code for "),a("code",[e._v("PREPARE")]),e._v(" message.")]),e._v(" "),a("li",[a("code",[e._v("COMMIT_MSG_CODE")]),e._v(": Fixed number "),a("code",[e._v("2")]),e._v(". Message code for "),a("code",[e._v("COMMIT")]),e._v(" message.")]),e._v(" "),a("li",[a("code",[e._v("ROUND_CHANGE_MSG_CODE")]),e._v(": Fixed number "),a("code",[e._v("3")]),e._v(". Message code for "),a("code",[e._v("ROUND CHANGE")]),e._v(" message")]),e._v(" "),a("li",[a("code",[e._v("VALIDATOR_LIMIT")]),e._v(": Number of validators to pass an authorization or de-authorization proposal.\n"),a("ul",[a("li",[e._v("Must be "),a("code",[e._v("floor(N / 2) + 1")]),e._v(" to enforce majority consensus on a chain.")])])])]),e._v(" "),a("h4",{attrs:{id:"block-header"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#block-header","aria-hidden":"true"}},[e._v("↳")]),e._v(" Block Header")]),e._v(" "),a("p",[e._v("Istanbul BFT does not add new block header fields. Instead, it follows Clique in repurposing the "),a("code",[e._v("ethash")]),e._v(" header fields as follows:")]),e._v(" "),a("ul",[a("li",[a("p",[a("code",[e._v("nonce")]),e._v(": Proposer proposal regarding the account defined by the beneficiary field.")]),e._v(" "),a("ul",[a("li",[e._v("Should be "),a("code",[e._v("NONCE_DROP")]),e._v(" to propose deauthorizing beneficiary as an existing validator.")]),e._v(" "),a("li",[e._v("Should be "),a("code",[e._v("NONCE_AUTH")]),e._v(" to propose authorizing beneficiary as a new validator.")]),e._v(" "),a("li",[a("strong",[e._v("Must")]),e._v(" be filled with zeroes, "),a("code",[e._v("NONCE_DROP")]),e._v(" or "),a("code",[e._v("NONCE_AUTH")])])])]),e._v(" "),a("li",[a("p",[a("code",[e._v("mixHash")]),e._v(": Fixed magic number "),a("code",[e._v("0x63746963616c2062797a616e74696e65206661756c7420746f6c6572616e6365")]),e._v(" for Istanbul block identification.")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("ommersHash")]),e._v(": Must be "),a("code",[e._v("UNCLE_HASH")]),e._v(" as uncles are meaningless outside of PoW.")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("timestamp")]),e._v(": Must be at least the parent timestamp + "),a("code",[e._v("BLOCK_PERIOD")])])]),e._v(" "),a("li",[a("p",[a("code",[e._v("difficulty")]),e._v(": Must be filled with "),a("code",[e._v("0x0000000000000001")]),e._v(".")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("extraData")]),e._v(": Combined field for signer vanity and RLP encoded Istanbul extra data, where Istanbul extra data contains validator list, proposer seal, and commit seals. Istanbul extra data is defined as follows:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("type IstanbulExtra struct {\n        Validators    []common.Address \t//Validator addresses\n        Seal          []byte\t        //Proposer seal 65 bytes\n        CommittedSeal [][]byte          //Committed seal, 65 * len(Validators) bytes\n}\n")])])]),a("p",[e._v("Thus the "),a("code",[e._v("extraData")]),e._v(" would be in the form of "),a("code",[e._v("EXTRA_VANITY | ISTANBUL_EXTRA")]),e._v(" where "),a("code",[e._v("|")]),e._v(" represents a fixed index to separate vanity and Istanbul extra data (not an actual character for separator).")]),e._v(" "),a("ul",[a("li",[e._v("First "),a("code",[e._v("EXTRA_VANITY")]),e._v(" bytes (fixed) may contain arbitrary proposer vanity data.")]),e._v(" "),a("li",[a("code",[e._v("ISTANBUL_EXTRA")]),e._v(" bytes are the RLP encoded Istanbul extra data calculated from "),a("code",[e._v("RLP(IstanbulExtra)")]),e._v(", where "),a("code",[e._v("RLP()")]),e._v(" is RLP encoding function, and "),a("code",[e._v("IstanbulExtra")]),e._v(" is the Istanbul extra data.\n"),a("ul",[a("li",[a("code",[e._v("Validators")]),e._v(": The list of validators, which "),a("strong",[e._v("must")]),e._v(" be sorted in ascending order.")]),e._v(" "),a("li",[a("code",[e._v("Seal")]),e._v(": The proposer's signature sealing of the header.")]),e._v(" "),a("li",[a("code",[e._v("CommittedSeal")]),e._v(": The list of commitment signature seals as consensus proof.")])])])])])]),e._v(" "),a("h4",{attrs:{id:"block-hash-proposer-seal-and-committed-seals"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#block-hash-proposer-seal-and-committed-seals","aria-hidden":"true"}},[e._v("↳")]),e._v(" Block hash, proposer seal and committed seals")]),e._v(" "),a("p",[e._v("The Istanbul block hash calculation is different from the "),a("code",[e._v("ethash")]),e._v(" block hash calculation due to the following reasons:")]),e._v(" "),a("ol",[a("li",[e._v("The proposer needs to put proposer's seal in "),a("code",[e._v("extraData")]),e._v(" to prove the block is signed by the chosen proposer.")]),e._v(" "),a("li",[e._v("The validators need to put "),a("code",[e._v("ceil(2N/3)")]),e._v(" of committed seals as consensus proof in "),a("code",[e._v("extraData")]),e._v(" to prove the block has gone through consensus.")])]),e._v(" "),a("p",[e._v("The calculation is still similar to the "),a("code",[e._v("ethash")]),e._v(" block hash calculation, with the exception that we need to deal with "),a("code",[e._v("extraData")]),e._v(". We calculate the fields as follows:")]),e._v(" "),a("h5",{attrs:{id:"proposer-seal-calculation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#proposer-seal-calculation","aria-hidden":"true"}},[e._v("↳")]),e._v(" Proposer seal calculation")]),e._v(" "),a("p",[e._v("By the time of proposer seal calculation, the committed seals are still unknown, so we calculate the seal with those unknowns empty. The calculation is as follows:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("Proposer seal")]),e._v(": "),a("code",[e._v("SignECDSA(Keccak256(RLP(Header)), PrivateKey)")])]),e._v(" "),a("li",[a("code",[e._v("PrivateKey")]),e._v(": Proposer's private key.")]),e._v(" "),a("li",[a("code",[e._v("Header")]),e._v(": Same as "),a("code",[e._v("ethash")]),e._v(" header only with a different "),a("code",[e._v("extraData")]),e._v(".")]),e._v(" "),a("li",[a("code",[e._v("extraData")]),e._v(": "),a("code",[e._v("vanity | RLP(IstanbulExtra)")]),e._v(", where in the "),a("code",[e._v("IstanbulExtra")]),e._v(", "),a("code",[e._v("CommittedSeal")]),e._v(" and "),a("code",[e._v("Seal")]),e._v(" are empty arrays.")])]),e._v(" "),a("h5",{attrs:{id:"block-hash-calculation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#block-hash-calculation","aria-hidden":"true"}},[e._v("↳")]),e._v(" Block hash calculation")]),e._v(" "),a("p",[e._v("While calculating block hash, we need to exclude committed seals since that data is dynamic between different validators. Therefore, we make "),a("code",[e._v("CommittedSeal")]),e._v(" an empty array while calculating the hash. The calculation is:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("Header")]),e._v(": Same as "),a("code",[e._v("ethash")]),e._v(" header only with a different "),a("code",[e._v("extraData")]),e._v(".")]),e._v(" "),a("li",[a("code",[e._v("extraData")]),e._v(": "),a("code",[e._v("vanity | RLP(IstanbulExtra)")]),e._v(", where in the "),a("code",[e._v("IstanbulExtra")]),e._v(", "),a("code",[e._v("CommittedSeal")]),e._v(" is an empty array.")])]),e._v(" "),a("h5",{attrs:{id:"consensus-proof"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#consensus-proof","aria-hidden":"true"}},[e._v("↳")]),e._v(" Consensus proof")]),e._v(" "),a("p",[e._v("Before inserting a block into the blockchain, each validator needs to collect "),a("code",[e._v("ceil(2N/3)")]),e._v(" of committed seals from other validators to compose a consensus proof. Once it receives enough committed seals, it will fill the "),a("code",[e._v("CommittedSeal")]),e._v(" in "),a("code",[e._v("IstanbulExtra")]),e._v(", recalculate the "),a("code",[e._v("extraData")]),e._v(", and then insert the block into the blockchain. "),a("strong",[e._v("Note")]),e._v(" that since committed seals can differ by different sources, we exclude that part while calculating the block hash as in the previous section.")]),e._v(" "),a("p",[e._v("Committed seal calculation:")]),e._v(" "),a("p",[e._v("Committed seal is calculated by each of the validators signing the hash along with "),a("code",[e._v("COMMIT_MSG_CODE")]),e._v(" message code of its private key. The calculation is as follows:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("Committed seal")]),e._v(": "),a("code",[e._v("SignECDSA(Keccak256(CONCAT(Hash, COMMIT_MSG_CODE)), PrivateKey)")]),e._v(".")]),e._v(" "),a("li",[a("code",[e._v("CONCAT(Hash, COMMIT_MSG_CODE)")]),e._v(": Concatenate block hash and "),a("code",[e._v("COMMIT_MSG_CODE")]),e._v(" bytes.")]),e._v(" "),a("li",[a("code",[e._v("PrivateKey")]),e._v(": Signing validator's private key.")])]),e._v(" "),a("h2",{attrs:{id:"provenance"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#provenance","aria-hidden":"true"}},[e._v("↳")]),e._v(" Provenance")]),e._v(" "),a("p",[e._v("Istanbul BFT implementation in Smilo is based on "),a("a",{attrs:{href:"https://github.com/ethereum/EIPs/issues/650",target:"_blank",rel:"noopener noreferrer"}},[e._v("EIP 650"),a("OutboundLink")],1),e._v(". It has been updated since the EIP was opened to resolve safety issues by introducing locking.")])])}),[],!1,null,null,null);o.default=s.exports}}]);