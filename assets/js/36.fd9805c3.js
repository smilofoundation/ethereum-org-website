(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{168:function(e,t,a){"use strict";a.r(t);var n=a(0),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"node-addition-examples"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#node-addition-examples","aria-hidden":"true"}},[e._v("↳")]),e._v(" Node addition examples")]),e._v(" "),a("p",[e._v("Below are some scenarios for adding a new node into a network, with a mix of different options such as\nconsensus algorithm, permissioning and discovery.")]),e._v(" "),a("p",[e._v("You can find the resources required to run the examples in the\n"),a("a",{attrs:{href:"https://github.com/smilofoundation/Smilo-examples/tree/master/examples/adding_nodes",target:"_blank",rel:"noopener noreferrer"}},[e._v("Smilo-examples"),a("OutboundLink")],1),e._v(" repository.\nCheckout the repository through "),a("code",[e._v("git")]),e._v(" or otherwise download all the resources your local machine to follow along.")]),e._v(" "),a("p",[e._v("The examples use "),a("code",[e._v("docker-compose")]),e._v(" for the container definitions. If you are following along by copying the commands\ndescribed, then it is important to set the project name for Docker Compose, or to remember to change the prefix for\nyour directory. See "),a("a",{attrs:{href:"https://docs.docker.com/compose/reference/envvars/#compose_project_name",target:"_blank",rel:"noopener noreferrer"}},[e._v("Docker documentation"),a("OutboundLink")],1),e._v("\nfor more details.")]),e._v(" "),a("p",[e._v("To set the project name, run the following:")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("$ "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("export")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("COMPOSE_PROJECT_NAME")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("addnode\n")])])]),a("h2",{attrs:{id:"non-permimssioned-ibft-with-discovery"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#non-permimssioned-ibft-with-discovery","aria-hidden":"true"}},[e._v("↳")]),e._v(" Non-permimssioned IBFT with discovery")]),e._v(" "),a("p",[e._v("An example using IBFT, no permissioning and discover enabled via a bootnode.\nThere are no static peers in this network; instead, every node is set to talk to node 1 via the CLI flag\n"),a("code",[e._v("--bootnodes enode://ac6b1096ca56b9f6d004b779ae3728bf83f8e22453404cc3cef16a3d9b96608bc67c4b30db88e0a5a6c6390213f7acbe1153ff6d23ce57380104288ae19373ef@172.16.239.11:21000")]),e._v(".\nNode 1 will forward the details of all the nodes it knows about (in this case, everyone) and they will then initiate their\nown connections.")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("Bring up an initial network of 6 nodes.")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Ensure any old network is removed")]),e._v("\n$ docker-compose -f ibft-non-perm-bootnode.yml down\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Bring up 6 nodes")]),e._v("\n$ docker-compose -f ibft-non-perm-bootnode.yml up node1 node2 node3 node4 node5 node6\n")])])])]),e._v(" "),a("li",[a("p",[e._v("Send in a public transaction and check it is minted.")]),e._v(" "),a("p",[e._v("!!! note\n* The block creation period is set to 2 seconds, so you may have to wait upto that amount of time for the transaction to be minted.\n* The transaction hashes will likely be different, but the contract addresses will be the same for your network.")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Send in the transaction")]),e._v("\n$ docker "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("exec")]),e._v(" -it addnode_node1_1 geth --exec "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'loadScript(\"/examples/public-contract.js\")'")]),e._v(" attach /qdata/dd/geth.ipc\nContract transaction send: TransactionHash: 0xd1bf0c15546802e5a121f79d0d8e6f0fa45d4961ef8ab9598885d28084cfa909 waiting to be mined"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("..")]),e._v(".\n"),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("true")]),e._v("\n    \n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Retrieve the value of the contract")]),e._v("\n$ docker "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("exec")]),e._v(" -it addnode_node1_1 geth --exec "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('\'var private = eth.contract([{"constant":true,"inputs":[],"name":"get","outputs":[{"name":"retVal","type":"uint256"}],"payable":false,"type":"function"}]).at("0x1932c48b2bf8102ba33b4a6b545c32236e342f34"); private.get();\'')]),e._v(" attach /qdata/dd/geth.ipc\n"),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("42")]),e._v("\n")])])]),a("p",[e._v("We created a transaction, in this case with hash "),a("code",[e._v("0xd1bf0c15546802e5a121f79d0d8e6f0fa45d4961ef8ab9598885d28084cfa909")]),e._v(",\nand then retrieved its value, which was set to be "),a("code",[e._v("42")]),e._v(".")])]),e._v(" "),a("li",[a("p",[e._v("Bring up the last node. This node also has its bootnodes set to be node 1, so at startup will try to establish a\nconnection to node 1 only. After this, node 1 will share which nodes it knows about, and node 7 can then initiate\nconnections with those peers.")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Bring up node 7")]),e._v("\n$ docker-compose -f ibft-non-perm-bootnode.yml up node7\n")])])])]),e._v(" "),a("li",[a("p",[e._v("Let's check to see if the nodes are in sync. If they are, they will have similar block numbers, which is enough for\nthis example; there are other ways to tell if nodes are on the same chain, e.g. matching block hashes.")]),e._v(" "),a("p",[e._v("!!! note\nDepending on timing, the second may have an extra block or two.")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Fetch the latest block number for node 1")]),e._v("\n$ docker "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("exec")]),e._v(" -it addnode_node1_1 geth --exec "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'eth.blockNumber'")]),e._v(" attach /qdata/dd/geth.ipc\n"),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("45")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Fetch the latest block number for node 7")]),e._v("\n$ docker "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("exec")]),e._v(" -it addnode_node7_1 geth --exec "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'eth.blockNumber'")]),e._v(" attach /qdata/dd/geth.ipc\n"),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("45")]),e._v("\n")])])])]),e._v(" "),a("li",[a("p",[e._v("We can check that the transaction and contract we sent earlier now exist on node 7.")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("$ docker "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("exec")]),e._v(" -it addnode_node7_1 geth --exec "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('\'var private = eth.contract([{"constant":true,"inputs":[],"name":"get","outputs":[{"name":"retVal","type":"uint256"}],"payable":false,"type":"function"}]).at("0x1932c48b2bf8102ba33b4a6b545c32236e342f34"); private.get();\'')]),e._v(" attach /qdata/dd/geth.ipc\n"),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("42")]),e._v("\n")])])])]),e._v(" "),a("li",[a("p",[e._v("To be sure we have two way communication, let's send a transaction from node 7 to the network.")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("$ docker "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("exec")]),e._v(" -it addnode_node7_1 geth --exec "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'loadScript(\"/examples/public-contract.js\")'")]),e._v(" attach /qdata/dd/geth.ipc\nContract transaction send: TransactionHash: 0x84cefc3aab8ce5797dc73c70db604e5c8830fc7c2cf215876eb34fff533e2725 waiting to be mined"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("..")]),e._v(".\n"),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("true")]),e._v("\n")])])])]),e._v(" "),a("li",[a("p",[e._v("Finally, we can check if the transaction was minted and the contract executed on each node.")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Check on node 1")]),e._v("\n$ docker "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("exec")]),e._v(" -it addnode_node1_1 geth --exec "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('\'var private = eth.contract([{"constant":true,"inputs":[],"name":"get","outputs":[{"name":"retVal","type":"uint256"}],"payable":false,"type":"function"}]).at("0x1349f3e1b8d71effb47b840594ff27da7e603d17"); private.get();\'')]),e._v(" attach /qdata/dd/geth.ipc\n"),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("42")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Check on node 7")]),e._v("\n$ docker "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("exec")]),e._v(" -it addnode_node7_1 geth --exec "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('\'var private = eth.contract([{"constant":true,"inputs":[],"name":"get","outputs":[{"name":"retVal","type":"uint256"}],"payable":false,"type":"function"}]).at("0x1349f3e1b8d71effb47b840594ff27da7e603d17"); private.get();\'')]),e._v(" attach /qdata/dd/geth.ipc\n"),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("42")]),e._v("\n")])])])])]),e._v(" "),a("p",[e._v("And that's it. We deployed a working 6 node network, and then added a 7th node afterwards; this 7th node was able to\nread existing public data, as well as deploy its own transactions and contracts for others to see!")]),e._v(" "),a("h2",{attrs:{id:"non-permissioned-raft-with-discovery-disabled"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#non-permissioned-raft-with-discovery-disabled","aria-hidden":"true"}},[e._v("↳")]),e._v(" Non-permissioned RAFT with discovery disabled")]),e._v(" "),a("p",[e._v("This example walks through adding a new node to a RAFT network. This network does not have permissioning for the\nEthereum peer-to-peer layer, and makes it connections solely based on who is listed in the nodes "),a("code",[e._v("static-nodes.json")]),e._v("\nfile.")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("Bring up an initial network of 6 nodes.")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Ensure any old network is removed")]),e._v("\n$ docker-compose -f raft-non-perm-nodiscover.yml down\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Bring up 6 nodes")]),e._v("\n$ docker-compose -f raft-non-perm-nodiscover.yml up node1 node2 node3 node4 node5 node6\n")])])])]),e._v(" "),a("li",[a("p",[e._v("Send in a public transaction and check it is minted.")]),e._v(" "),a("p",[e._v("!!! note\n* The transaction hashes will likely be different, but the contract addresses will be the same for your network.")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Send in the transaction")]),e._v("\n$ docker "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("exec")]),e._v(" -it addnode_node1_1 geth --exec "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'loadScript(\"/examples/public-contract.js\")'")]),e._v(" attach /qdata/dd/geth.ipc\nContract transaction send: TransactionHash: 0xd1bf0c15546802e5a121f79d0d8e6f0fa45d4961ef8ab9598885d28084cfa909 waiting to be mined"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("..")]),e._v(".\n"),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("true")]),e._v("\n    \n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Retrieve the value of the contract")]),e._v("\n$ docker "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("exec")]),e._v(" -it addnode_node1_1 geth --exec "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('\'var private = eth.contract([{"constant":true,"inputs":[],"name":"get","outputs":[{"name":"retVal","type":"uint256"}],"payable":false,"type":"function"}]).at("0x1932c48b2bf8102ba33b4a6b545c32236e342f34"); private.get();\'')]),e._v(" attach /qdata/dd/geth.ipc\n"),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("42")]),e._v("\n")])])]),a("p",[e._v("We created a transaction, in this case with hash "),a("code",[e._v("0xd1bf0c15546802e5a121f79d0d8e6f0fa45d4961ef8ab9598885d28084cfa909")]),e._v(",\nand then retrieved its value, which was set to be "),a("code",[e._v("42")]),e._v(".")])]),e._v(" "),a("li",[a("p",[e._v("We need to add the new peer to the RAFT network before it joins, otherwise the existing nodes will reject it from\nthe RAFT communication layer; we also need to know what ID the new node should join with.")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Add the new node")]),e._v("\n$ docker "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("exec")]),e._v(" -it addnode_node1_1 geth --exec "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'raft.addPeer(\"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@172.16.239.17:21000?discport=0&raftport=50400\")'")]),e._v(" attach /qdata/dd/geth.ipc\n"),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("7")]),e._v("\n")])])]),a("p",[e._v("The return value is the RAFT ID of the new node. When the node joins the network for the first time, it will need\nthis ID number handy. If it was lost, you can always view the full network, including IDs, by running the\n"),a("code",[e._v("raft.cluster")]),e._v(" command on an existing node.")])]),e._v(" "),a("li",[a("p",[e._v("Bring up the last node. Here, we pass the newly created ID number as a flag into the startup of node 7. This lets\nthe node know to not bootstrap a new network from the contents of "),a("code",[e._v("static-nodes.json")]),e._v(", but to connect to an existing\nnode there are fetch any bootstrap information.")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Bring up node 7")]),e._v("\n$ "),a("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("QUORUM_GETH_ARGS")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"--raftjoinexisting 7"')]),e._v(" docker-compose -f raft-non-perm-nodiscover.yml up node7\n")])])])]),e._v(" "),a("li",[a("p",[e._v("Let's check to see if the nodes are in sync. We can do by seeing if we have the contract that we viewer earlier on\nnode 7.")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Fetch the contracts value on node 7")]),e._v("\n$ docker "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("exec")]),e._v(" -it addnode_node7_1 geth --exec "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('\'var private = eth.contract([{"constant":true,"inputs":[],"name":"get","outputs":[{"name":"retVal","type":"uint256"}],"payable":false,"type":"function"}]).at("0x1932c48b2bf8102ba33b4a6b545c32236e342f34"); private.get();\'')]),e._v(" attach /qdata/dd/geth.ipc\n"),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("42")]),e._v("\n")])])])]),e._v(" "),a("li",[a("p",[e._v("To be sure we have two way communication, let's send a transaction from node 7 to the network.")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("$ docker "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("exec")]),e._v(" -it addnode_node7_1 geth --exec "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'loadScript(\"/examples/public-contract.js\")'")]),e._v(" attach /qdata/dd/geth.ipc\nContract transaction send: TransactionHash: 0x84cefc3aab8ce5797dc73c70db604e5c8830fc7c2cf215876eb34fff533e2725 waiting to be mined"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("..")]),e._v(".\n"),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("true")]),e._v("\n")])])])]),e._v(" "),a("li",[a("p",[e._v("Finally, we can check if the transaction was minted and the contract executed on each node.")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Check on node 1")]),e._v("\n$ docker "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("exec")]),e._v(" -it addnode_node1_1 geth --exec "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('\'var private = eth.contract([{"constant":true,"inputs":[],"name":"get","outputs":[{"name":"retVal","type":"uint256"}],"payable":false,"type":"function"}]).at("0x1349f3e1b8d71effb47b840594ff27da7e603d17"); private.get();\'')]),e._v(" attach /qdata/dd/geth.ipc\n"),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("42")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Check on node 7")]),e._v("\n$ docker "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("exec")]),e._v(" -it addnode_node7_1 geth --exec "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('\'var private = eth.contract([{"constant":true,"inputs":[],"name":"get","outputs":[{"name":"retVal","type":"uint256"}],"payable":false,"type":"function"}]).at("0x1349f3e1b8d71effb47b840594ff27da7e603d17"); private.get();\'')]),e._v(" attach /qdata/dd/geth.ipc\n"),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("42")]),e._v("\n")])])])])]),e._v(" "),a("p",[e._v("And that's it. We deployed a working 6 node network, and then added a 7th node afterwards; this 7th node was able to\nread existing public data, as well as deploy its own transactions and contracts for others to see!")]),e._v(" "),a("h2",{attrs:{id:"permissioned-raft-with-discovery-disabled"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#permissioned-raft-with-discovery-disabled","aria-hidden":"true"}},[e._v("↳")]),e._v(" Permissioned RAFT with discovery disabled")]),e._v(" "),a("p",[e._v("This example walks through adding a new node to a RAFT network. This network does have permissioning enabled for the\nEthereum peer-to-peer layer; this means that for any Ethereum tasks, such as syncing the initial blockchain or\npropagating transactions, the node must appear is others nodes' "),a("code",[e._v("permissioned-nodes.json")]),e._v(" file.")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("Bring up an initial network of 6 nodes.")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Ensure any old network is removed")]),e._v("\n$ docker-compose -f raft-perm-nodiscover.yml down\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Bring up 6 nodes")]),e._v("\n$ docker-compose -f raft-perm-nodiscover.yml up node1 node2 node3 node4 node5 node6\n")])])])]),e._v(" "),a("li",[a("p",[e._v("Send in a public transaction and check it is minted.")]),e._v(" "),a("p",[e._v("!!! note\n* The transaction hashes will likely be different, but the contract addresses will be the same for your network.")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Send in the transaction")]),e._v("\n$ docker "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("exec")]),e._v(" -it addnode_node1_1 geth --exec "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'loadScript(\"/examples/public-contract.js\")'")]),e._v(" attach /qdata/dd/geth.ipc\nContract transaction send: TransactionHash: 0xd1bf0c15546802e5a121f79d0d8e6f0fa45d4961ef8ab9598885d28084cfa909 waiting to be mined"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("..")]),e._v(".\n"),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("true")]),e._v("\n    \n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Retrieve the value of the contract")]),e._v("\n$ docker "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("exec")]),e._v(" -it addnode_node1_1 geth --exec "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('\'var private = eth.contract([{"constant":true,"inputs":[],"name":"get","outputs":[{"name":"retVal","type":"uint256"}],"payable":false,"type":"function"}]).at("0x1932c48b2bf8102ba33b4a6b545c32236e342f34"); private.get();\'')]),e._v(" attach /qdata/dd/geth.ipc\n"),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("42")]),e._v("\n")])])]),a("p",[e._v("We created a transaction, in this case with hash "),a("code",[e._v("0xd1bf0c15546802e5a121f79d0d8e6f0fa45d4961ef8ab9598885d28084cfa909")]),e._v(",\nand then retrieved its value, which was set to be "),a("code",[e._v("42")]),e._v(".")])]),e._v(" "),a("li",[a("p",[e._v("We need to add the new peer to the RAFT network before it joins, otherwise the existing nodes will reject it from\nthe RAFT communication layer; we also need to know what ID the new node should join with.")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Add the new node")]),e._v("\n$ docker "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("exec")]),e._v(" -it addnode_node1_1 geth --exec "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'raft.addPeer(\"enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@172.16.239.17:21000?discport=0&raftport=50400\")'")]),e._v(" attach /qdata/dd/geth.ipc\n"),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("7")]),e._v("\n")])])]),a("p",[e._v("The return value is the RAFT ID of the new node. When the node joins the network for the first time, it will need\nthis ID number handy. If it was lost, you can always view the full network, including IDs, by running the\n"),a("code",[e._v("raft.cluster")]),e._v(" command on an existing node.")])]),e._v(" "),a("li",[a("p",[e._v("Bring up the last node. Here, we pass the newly created ID number as a flag into the startup of node 7. This lets\nthe node know to not bootstrap a new network from the contents of "),a("code",[e._v("static-nodes.json")]),e._v(", but to connect to an existing\nnode there are fetch any bootstrap information.")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Bring up node 7")]),e._v("\n$ "),a("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("QUORUM_GETH_ARGS")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"--raftjoinexisting 7"')]),e._v(" docker-compose -f raft-non-perm-nodiscover.yml up node7\n")])])])]),e._v(" "),a("li",[a("p",[e._v("Let's check to see if the nodes are in sync. We can do by seeing if we have the contract that we viewer earlier on\nnode 7.")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Fetch the contracts value on node 7")]),e._v("\n$ docker "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("exec")]),e._v(" -it addnode_node7_1 geth --exec "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('\'var private = eth.contract([{"constant":true,"inputs":[],"name":"get","outputs":[{"name":"retVal","type":"uint256"}],"payable":false,"type":"function"}]).at("0x1932c48b2bf8102ba33b4a6b545c32236e342f34"); private.get();\'')]),e._v(" attach /qdata/dd/geth.ipc\n"),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),e._v("\n")])])]),a("p",[e._v("The value here is "),a("code",[e._v("0")]),e._v(", not the expected "),a("code",[e._v("42")]),e._v("! Node 7 is unable to sync the blockchain because the other peers in the\nnetwork are refusing to allow connections from node 7, due to it being missing in the "),a("code",[e._v("permissioned-nodes.json")]),e._v(" file.")]),e._v(" "),a("p",[e._v("This does not affect the RAFT layer, so if node 7 was already is sync, it could still receive new blocks; this is\nokay though, since it would be permissioned on the RAFT side by virtue of being part of the RAFT cluster.")])]),e._v(" "),a("li",[a("p",[e._v("Let's update the permissioned nodes list on node 1, which will allow node 7 to connect to it.")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("$ docker "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("exec")]),e._v(" -it addnode_node1_1 "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("cp")]),e._v(" /extradata/static-nodes-7.json /qdata/dd/permissioned-nodes.json\n$\n")])])])]),e._v(" "),a("li",[a("p",[e._v("Node 7 should now be synced up through node 1. Let's see if we can see the contract we made earlier.")]),e._v(" "),a("p",[e._v("!!! note\nSmilo attempts to re-establish nodes every 30 seconds, so you may have to wait for the sync to happen.")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("$ docker "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("exec")]),e._v(" -it addnode_node7_1 geth --exec "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('\'var private = eth.contract([{"constant":true,"inputs":[],"name":"get","outputs":[{"name":"retVal","type":"uint256"}],"payable":false,"type":"function"}]).at("0x1932c48b2bf8102ba33b4a6b545c32236e342f34"); private.get();\'')]),e._v(" attach /qdata/dd/geth.ipc\n"),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("42")]),e._v("\n")])])])]),e._v(" "),a("li",[a("p",[e._v("To be sure we have two way communication, let's send a transaction from node 7 to the network.")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("$ docker "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("exec")]),e._v(" -it addnode_node7_1 geth --exec "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'loadScript(\"/examples/public-contract.js\")'")]),e._v(" attach /qdata/dd/geth.ipc\nContract transaction send: TransactionHash: 0x84cefc3aab8ce5797dc73c70db604e5c8830fc7c2cf215876eb34fff533e2725 waiting to be mined"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("..")]),e._v(".\n"),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("true")]),e._v("\n")])])])]),e._v(" "),a("li",[a("p",[e._v("Finally, we can check if the transaction was minted and the contract executed on each node.")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Check on node 1")]),e._v("\n$ docker "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("exec")]),e._v(" -it addnode_node1_1 geth --exec "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('\'var private = eth.contract([{"constant":true,"inputs":[],"name":"get","outputs":[{"name":"retVal","type":"uint256"}],"payable":false,"type":"function"}]).at("0x1349f3e1b8d71effb47b840594ff27da7e603d17"); private.get();\'')]),e._v(" attach /qdata/dd/geth.ipc\n"),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("42")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Check on node 7")]),e._v("\n$ docker "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("exec")]),e._v(" -it addnode_node7_1 geth --exec "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('\'var private = eth.contract([{"constant":true,"inputs":[],"name":"get","outputs":[{"name":"retVal","type":"uint256"}],"payable":false,"type":"function"}]).at("0x1349f3e1b8d71effb47b840594ff27da7e603d17"); private.get();\'')]),e._v(" attach /qdata/dd/geth.ipc\n"),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("42")]),e._v("\n")])])])])]),e._v(" "),a("p",[e._v("And that's it. We deployed a working 6 node network, and then added a 7th node afterwards; this 7th node was able to\nread existing public data, as well as deploy its own transactions and contracts for others to see!")]),e._v(" "),a("h2",{attrs:{id:"adding-a-private-transaction-manager"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#adding-a-private-transaction-manager","aria-hidden":"true"}},[e._v("↳")]),e._v(" Adding a Private Transaction Manager")]),e._v(" "),a("p",[e._v("This is a simple example of adding a new Tessera instance to an existing network. For simplicity,\nthe steps to add the Smilo node are omitted, but are those followed in the IBFT example.\nHere, a Tessera node is added without any of the discovery options specified, meaning that the\nIP Whitelist isn't used, nor is key discovery disabled.")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("Start up the initial 6 node network.")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Ensure any old network is removed")]),e._v("\n$ docker-compose -f tessera-add.yml down\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Bring up 6 nodes")]),e._v("\n$ docker-compose -f tessera-add.yml up node1 node2 node3 node4 node5 node6\n")])])])]),e._v(" "),a("li",[a("p",[e._v("We can verify that private transactions can be sent by sending one from node 1 to node 6.\nWe can also see that since node 7 doesn't exist yet, we can't send private transactions to it.")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Send a private transaction from node 1 to node 6")]),e._v("\n$ docker "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("exec")]),e._v(" -it addnode_node1_1 geth --exec "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'loadScript(\"/examples/private-contract-6.js\")'")]),e._v(" attach /qdata/dd/geth.ipc\nContract transaction send: TransactionHash: 0xc8a5de4bb79d4a8c3c1156917968ca9b2965f2514732fc1cff357ec999b9aba4 waiting to be mined"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("..")]),e._v(".\n"),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("true")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Success! ")]),e._v("\n\n$ docker "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("exec")]),e._v(" -it addnode_node1_1 geth --exec "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'loadScript(\"/examples/private-contract-7.js\")'")]),e._v(" attach /qdata/dd/geth.ipc\nerr creating contract Error: Non-200 status code: "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("&")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("Status:404 Not Found StatusCode:404 Proto:HTTP/1.1 ProtoMajor:1 ProtoMinor:1 Header:map"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("Server:"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("Jetty"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("9.4")]),e._v(".z-SNAPSHOT"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" Date:"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("Thu, "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("16")]),e._v(" Jan "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("2020")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("12")]),e._v(":44:19 GMT"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" Content-Type:"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("text/plain"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" Content-Length:"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("73")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" Body:0xc028e87d40 ContentLength:73 TransferEncoding:"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" Close:false Uncompressed:false Trailer:map"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" Request:0xc000287200 TLS:"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("nil"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("true")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# An expected failure. The script content didn't succeed, but the script itself was run okay, so true was still returned")]),e._v("\n")])])])]),e._v(" "),a("li",[a("p",[e._v("Let's first bring up node 7, then we can inspect what is happening and the configuration used.")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Bring up node 7")]),e._v("\n$ docker-compose -f tessera-add.yml up node7 \n\n$ docker "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("exec")]),e._v(" -it addnode_node7_1 "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("cat")]),e._v(" /qdata/tm/tessera-config.json\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# ...some output...")]),e._v("\n")])])]),a("p",[e._v("The last command will output Tessera 7's configuration.\nThe pieces we are interested in here are the following:")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"useWhiteList"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("false")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n   "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"peer"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n          "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"url"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"http://txmanager1:9000"')]),e._v("\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n   "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n   ...\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("We can see that the whitelist is not enabled, discovery is not specified so defaults to enabled,\nand we have a single peer to start off with, which is node 1.\nThis is all that is needed to connect to an existing network. Shortly after starting up, Tessera\nwill ask node 1 about all it's peers, and then will keep a record of them for it's own use. From\nthen on, all the nodes will know about node 7 and can send private transactions to it.")])]),e._v(" "),a("li",[a("p",[e._v("Let's try it! Let's send a private transaction from node 1 to the newly added node 7.")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Sending a transaction from node 1 to node 7")]),e._v("\n$ docker "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("exec")]),e._v(" -it addnode_node1_1 geth --exec "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'loadScript(\"/examples/private-contract-7.js\")'")]),e._v(" attach /qdata/dd/geth.ipc\nContract transaction send: TransactionHash: 0x3e3b50768ffdb51979677ddb58f48abdabb82a3fd4f0bac5b3d1ad8014e954e9 waiting to be mined"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("..")]),e._v(".\n"),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("true")]),e._v("\n")])])]),a("p",[e._v("We got a success this time! Tessera 7 has been accepted into the network and can interact with the\nother existing nodes.")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);