(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{249:function(e,t,o){"use strict";o.r(t);var i=o(0),a=Object(i.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"ibft-parameters"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#ibft-parameters","aria-hidden":"true"}},[e._v("↳")]),e._v(" IBFT parameters")]),e._v(" "),o("h2",{attrs:{id:"cli-options"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#cli-options","aria-hidden":"true"}},[e._v("↳")]),e._v(" CLI options")]),e._v(" "),o("h3",{attrs:{id:"block-period"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#block-period","aria-hidden":"true"}},[e._v("↳")]),e._v(" Block period")]),e._v(" "),o("p",[o("code",[e._v("--istanbul.blockperiod 1")])]),e._v(" "),o("p",[e._v("Setting the block period is used for how long blocks should be minted by the validators. It is also used for validation\nof block times by all nodes, so should not be changed after deciding a value for the network.\nThe setting is a positive integer, and measures the minimum numbers of seconds before the next block is considered\nvalid.")]),e._v(" "),o("p",[e._v("The default value is "),o("code",[e._v("1")]),e._v(".")]),e._v(" "),o("h3",{attrs:{id:"request-timeout"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#request-timeout","aria-hidden":"true"}},[e._v("↳")]),e._v(" Request timeout")]),e._v(" "),o("p",[o("code",[e._v("--istanbul.requesttimeout 10000")])]),e._v(" "),o("p",[e._v("The request timeout is the timeout at which IBFT will seek to trigger a new round if the previous one did not complete.\nThis period increases are the timeout is hit more often. This parameter sets the minimum timeout in the case of normal\noperation and is measured in milliseconds.")]),e._v(" "),o("p",[e._v("The default value is "),o("code",[e._v("10000")]),e._v(".")]),e._v(" "),o("h2",{attrs:{id:"genesis-file-options"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#genesis-file-options","aria-hidden":"true"}},[e._v("↳")]),e._v(" Genesis file options")]),e._v(" "),o("p",[e._v("Within the "),o("code",[e._v("genesis.json")]),e._v(" file, there is an area for IBFT specific configuration, much like a Clique network\nconfiguration.")]),e._v(" "),o("p",[e._v("The options are as follows:")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v('{\n    "config": {\n        "istanbul": {\n            "epoch": 30000,\n            "policy": 0,\n            "ceil2Nby3Block": 0\n        },\n        ...\n    },\n    ...\n}\n')])])]),o("h3",{attrs:{id:"epoch"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#epoch","aria-hidden":"true"}},[e._v("↳")]),e._v(" Epoch")]),e._v(" "),o("p",[e._v("The epoch specifies the number of blocks that should pass before pending validator votes are reset. When the\n"),o("code",[e._v("blocknumber%EPOCH == 0")]),e._v(", the votes are reset in order to prevent a single vote from becoming stale. If the existing\nvote was still due to take place, then it must be resubmitted, along with all its votes.")]),e._v(" "),o("h3",{attrs:{id:"policy"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#policy","aria-hidden":"true"}},[e._v("↳")]),e._v(" Policy")]),e._v(" "),o("p",[e._v("The policy refers to the proposer selection policy, which is either "),o("code",[e._v("ROUND_ROBIN")]),e._v(" or "),o("code",[e._v("STICKY")]),e._v(".")]),e._v(" "),o("p",[e._v("A value of "),o("code",[e._v("0")]),e._v(" denotes a "),o("code",[e._v("ROUND_ROBIN")]),e._v(" policy, where the next expected proposer is the next in queue. Once a proposer\nhas submitted a valid block, they join the back of the queue and must wait their turn again.")]),e._v(" "),o("p",[e._v("A value of "),o("code",[e._v("1")]),e._v(" denotes a "),o("code",[e._v("STICKY")]),e._v(" proposer policy, where a single proposer is selected to mint blocks and does so until\nsuch a time as they go offline or are otherwise unreachable.")]),e._v(" "),o("h3",{attrs:{id:"ceil2nby3block"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#ceil2nby3block","aria-hidden":"true"}},[e._v("↳")]),e._v(" ceil2Nby3Block")]),e._v(" "),o("p",[e._v("The "),o("code",[e._v("ceil2Nby3Block")]),e._v(" sets the block number from which to use an updated formula for calculating the number of faulty\nnodes. This was introduced to enable existing network the ability to upgrade at a point in the future of the network, as\nit is incompatible with the existing formula. For new networks, it is recommended to set this value to "),o("code",[e._v("0")]),e._v(" to use the\nupdated formula immediately.")]),e._v(" "),o("p",[e._v("To update this value, the same process can be followed as other hard-forks.")])])}),[],!1,null,null,null);t.default=a.exports}}]);