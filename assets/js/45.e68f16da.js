(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{277:function(e,n,a){"use strict";a.r(n);var t=a(0),i=Object(t.a)({},(function(){var e=this,n=e.$createElement,a=e._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("title: Internals - Pluggable Architecture - Smilo")]),e._v(" "),a("h2",{attrs:{id:"background"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#background","aria-hidden":"true"}},[e._v("↳")]),e._v(" Background")]),e._v(" "),a("h3",{attrs:{id:"go-plugin"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#go-plugin","aria-hidden":"true"}},[e._v("↳")]),e._v(" Go Plugin")]),e._v(" "),a("p",[a("code",[e._v("geth")]),e._v(" is written in the Go programming language. "),a("a",{attrs:{href:"https://golang.org/doc/go1.8#plugin",target:"_blank",rel:"noopener noreferrer"}},[e._v("Go 1.8 introduced"),a("OutboundLink")],1),e._v(" a new plugin architecture\nwhich allows for the creation of plugins (via "),a("code",[e._v("plugin")]),e._v(" build mode) and to use these plugins at runtime (via "),a("code",[e._v("plugin")]),e._v(" package).\nIn order to utilize this architecture, there are strict requirements in developing plugins.")]),e._v(" "),a("p",[e._v("By using the network RPC interface, the plugin is independently built and distributed without having to rebuild "),a("code",[e._v("geth")]),e._v(".\nEspecially with gRPC interfaces, plugins can be written in different languages (see our "),a("router-link",{attrs:{to:"/PluginDevelopment/#examples"}},[e._v("examples")]),e._v(").\nThis makes it easy for you to build a prototype feature or even a proprietary plugin for your organization's internal use.")],1),e._v(" "),a("p",[e._v("We use HashiCorp's "),a("a",{attrs:{href:"https://github.com/hashicorp/go-plugin",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("go-plugin")]),a("OutboundLink")],1),e._v(" library as it fits our asks\nand it has been proven in many plugin-based production systems.")]),e._v(" "),a("h3",{attrs:{id:"why-we-decided-to-use-plugins"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#why-we-decided-to-use-plugins","aria-hidden":"true"}},[e._v("↳")]),e._v(" Why we decided to use plugins")]),e._v(" "),a("p",[e._v("There are number of benefits:")]),e._v(" "),a("ul",[a("li",[e._v("Dynamically-linked binaries (which you get when using plugins) are much smaller than statically compiled binaries.")]),e._v(" "),a("li",[e._v("We value the ability to isolate failures. E.g.: Smilo client would continue mining/validating even if security plugin has crashed.")]),e._v(" "),a("li",[e._v("Easily enables support for open source plugins written in languages other than Go.")])]),e._v(" "),a("h2",{attrs:{id:"design"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#design","aria-hidden":"true"}},[e._v("↳")]),e._v(" Design")]),e._v(" "),a("div",{staticClass:"language-plantuml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('skinparam componentStyle uml2\nskinparam shadowing false\nskinparam backgroundColor transparent\nskinparam rectangle {\n    roundCorner<<component>> 25\n}\n\nfile "JSON File" as json\nfile "TOML File" as toml\nnote left of toml : Standard Ethereum Config\nnote right of json : Smilo Plugin Settings\n\nnode "geth" <<process>> {\n    rectangle "CLI Flags" as flags\n    frame "plugin.Settings" as settings {\n        storage "Plugin1\\nDefinition" as pd1\n        storage "Plugin2\\nDefinition" as pd2\n        storage "Plugin Central\\nConnectivity" as pcc\n    }\n\n    json <-down- flags : "via\\n""--plugins"""\n    toml <-down- flags : "via\\n""--config"""\n    flags -down-> settings : populate\n\n    interface """node.Service""" as service\n    rectangle """plugin.PluginManager""" <<geth service>> as pm\n    note right of pm\n    registered and managed\n    as standard ""geth""\n    service life cycle\n    end note\n\n    pm -up- service\n    pm -up- settings\n\n    card "arbitrary" <<component>> as arbitrary\n    interface "internal1" as i1\n    interface "internal2" as i2\n    interface "internal3" as i3\n\n    package "Plugin Interface 1" {\n        rectangle "Plugin1" <<template>> as p1\n        rectangle "Gateway1" <<adapter>> as p1gw1\n        rectangle "Gateway2" <<adapter>> as p1gw2\n\n        interface "grpc service interface1A" as grpcI1A\n        interface "grpc service interface1B" as grpcI1B\n\n        rectangle "GRPC Stub Client1" <<grpc client>> as grpcC1\n    }\n    \n    package "Plugin Interface 2" {\n        rectangle "Plugin2" <<template>> as p2    \n        rectangle "Gateway" <<adapter>> as p2gw\n\n        interface "grpc service interface2" as grpcI2\n\n        rectangle "GRPC Stub Client2" <<grpc client>> as grpcC2\n    }\n\n    pm -- p1\n    pm -- p2\n\n    arbitrary --( i1\n    arbitrary --( i2\n    arbitrary --( i3\n\n    p1gw1 -- i1\n    p1gw2 -- i2\n    p2gw -- i3\n\n    p1 -- p1gw1\n    p1 -- p1gw2\n    p2 -- p2gw\n\n    grpcC1 --( grpcI1A\n    grpcC1 --( grpcI1B\n    grpcC2 --( grpcI2\n\n    p1gw1 --\x3e grpcC1 : use\n    p1gw2 --\x3e grpcC1 : use\n    p2gw --\x3e grpcC2 : use\n}\n\nnode "Plugin1" <<process>> {\n    rectangle "Implementation" <<grpc server>> as impl1\n}\n\nnode "Plugin2" <<process>> {\n    rectangle "Implementation" <<grpc server>> as impl2\n}\n\nimpl1 -up- grpcI1A\nimpl1 -up- grpcI1B\nimpl2 -up- grpcI2\n\n')])])]),a("h3",{attrs:{id:"discovery"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#discovery","aria-hidden":"true"}},[e._v("↳")]),e._v(" Discovery")]),e._v(" "),a("p",[e._v("The Smilo client reads the plugin "),a("a",{attrs:{href:"../Settings"}},[e._v("settings")]),e._v(" file to determine which plugins are going to be loaded and searches for installed plugins\n("),a("code",[e._v("<name>-<version>.zip")]),e._v(" files) in the plugin "),a("code",[e._v("baseDir")]),e._v(" (defaults to "),a("code",[e._v("<datadir>/plugins")]),e._v("). If the required plugin doesnt exist in the path, Smilo will attempt to use the configured "),a("code",[e._v("plugin central")]),e._v(" to download the plugin.")]),e._v(" "),a("h3",{attrs:{id:"pluginmanager"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pluginmanager","aria-hidden":"true"}},[e._v("↳")]),e._v(" PluginManager")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("PluginManager")]),e._v(" manages the plugins being used inside "),a("code",[e._v("geth")]),e._v(". It reads the "),a("a",{attrs:{href:"../Settings"}},[e._v("configuration")]),e._v(" and builds a registry of plugins.\n"),a("code",[e._v("PluginManager")]),e._v(" implements the standard "),a("code",[e._v("Service")]),e._v(" interface in "),a("code",[e._v("geth")]),e._v(", hence being embedded into the "),a("code",[e._v("geth")]),e._v(" service life cycle, i.e.: expose service APIs, start and stop.\nThe "),a("code",[e._v("PluginManager")]),e._v(" service is registered as early as possible in the node lifecycle. This is to ensure the node fails fast if an issue is encountered when registering the "),a("code",[e._v("PluginManager")]),e._v(", so as not to impact other services.")]),e._v(" "),a("h3",{attrs:{id:"plugin-reloading"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#plugin-reloading","aria-hidden":"true"}},[e._v("↳")]),e._v(" Plugin Reloading")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("PluginManager")]),e._v(" exposes an API ("),a("code",[e._v("admin_reloadPlugin")]),e._v(") that allows reloading a plugin. This attempts to restart the current plugin process.")]),e._v(" "),a("p",[e._v("Any changes to the plugin config after initial node start will be applied when reloading the plugin."),a("br"),e._v("\nThis is demonstrated in the "),a("router-link",{attrs:{to:"/Overview/#example-helloworld-plugin"}},[e._v("HelloWorld plugin example")]),e._v(".")],1)])}),[],!1,null,null,null);n.default=i.exports}}]);