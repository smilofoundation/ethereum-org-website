(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{188:function(e,t,n){"use strict";n.r(t);var a=n(0),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"adding-nodes-to-the-network"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#adding-nodes-to-the-network","aria-hidden":"true"}},[e._v("↳")]),e._v(" Adding nodes to the network")]),e._v(" "),n("p",[e._v("Adding new nodes to an existing network can range from a common occurence to never happening.\nIn public blockchains, such as the Ethereum Mainnet, new nodes continuously join and talk to the existing network.\nIn permissioned blockchains, this may not happen as often, but it still an important task to achieve as your network\nevolves.")]),e._v(" "),n("p",[e._v("When adding new nodes to the network, it is important understand that the Smilo network and Private Transaction\nManager network are distinct and do not overlap in any way. Therefore, options applicable to one are not applicable to\nthe other. In some cases, they may have their own options to achieve similar tasks, but must be specified separately.")]),e._v(" "),n("h2",{attrs:{id:"prerequisites"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#prerequisites","aria-hidden":"true"}},[e._v("↳")]),e._v(" Prerequisites")]),e._v(" "),n("ul",[n("li",[n("router-link",{attrs:{to:"/Getting Started/Installing.html"}},[e._v("Smilo installed")])],1),e._v(" "),n("li",[n("router-link",{attrs:{to:"/Getting Started/Installing.html"}},[e._v("Tessera/Constellation installed")]),e._v(" if using private transactions")],1),e._v(" "),n("li",[e._v("A running network (see "),n("a",{attrs:{href:"/Getting%20Started/Creating-A-Network-From-Scratch"}},[e._v("Creating a Network From Scratch")]),e._v(")")])]),e._v(" "),n("h2",{attrs:{id:"adding-smilo-nodes"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#adding-smilo-nodes","aria-hidden":"true"}},[e._v("↳")]),e._v(" Adding Smilo nodes")]),e._v(" "),n("p",[e._v("Adding a new Smilo node is the most common operation, as you can choose to run a Smilo node with or without a Private\nTransaction Manager, but rarely will one do the opposite.")]),e._v(" "),n("h3",{attrs:{id:"raft"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#raft","aria-hidden":"true"}},[e._v("↳")]),e._v(" Raft")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("On an "),n("em",[e._v("existing")]),e._v(" node, add the new peer to the raft network")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('> raft.addPeer("enode://239c1f044a2b03b6c4713109af036b775c5418fe4ca63b04b1ce00124af00ddab7cc088fc46020cdc783b6207efe624551be4c06a994993d8d70f684688fb7cf@127.0.0.1:21006?discport=0&raftport=50407")\n7\n')])])]),n("p",[e._v("So in this example, our new node has a Raft ID of "),n("code",[e._v("7")]),e._v(".")])]),e._v(" "),n("li",[n("p",[e._v("If you are using permissioning, or discovery for Ethereum p2p, please refer "),n("a",{attrs:{href:"#extra-options"}},[e._v("here")]),e._v(".")])]),e._v(" "),n("li",[n("p",[e._v("We now need to initialise the new node with the network's genesis configuration.")]),e._v(" "),n("p",[e._v("!!! note\nWhere you obtain this from will be dependent on the network. You may get it from an existing peer, or a network operator, or elsewhere entirely.")]),e._v(" "),n("p",[e._v("Initialising the new node is exactly the same an the original nodes.")]),e._v(" "),n("div",{staticClass:"language-bash extra-class"},[n("pre",{pre:!0,attrs:{class:"language-bash"}},[n("code",[e._v("$ geth --datadir qdata/dd7 init genesis.json\n")])])])]),e._v(" "),n("li",[n("p",[e._v("Now we can start up the new node and let it sync with the network. The main difference now is the use of the\n"),n("code",[e._v("--raftjoinexisting")]),e._v(" flag, which lets the node know that it is joining an existing network, which is handled\ndifferently internally. The Raft ID obtained in step 1 is passed as a parameter to this flag.")]),e._v(" "),n("div",{staticClass:"language-bash extra-class"},[n("pre",{pre:!0,attrs:{class:"language-bash"}},[n("code",[e._v("$ "),n("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("PRIVATE_CONFIG")]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("ignore geth --datadir qdata/dd7 "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("..")]),e._v(". OTHER ARGS "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("..")]),e._v(". --raft --raftport "),n("span",{pre:!0,attrs:{class:"token number"}},[e._v("50407")]),e._v(" --rpcport "),n("span",{pre:!0,attrs:{class:"token number"}},[e._v("22006")]),e._v(" --port "),n("span",{pre:!0,attrs:{class:"token number"}},[e._v("21006")]),e._v(" --raftjoinexisting "),n("span",{pre:!0,attrs:{class:"token number"}},[e._v("7")]),e._v("\n")])])]),n("p",[e._v("The new node is now up and running, and will start syncing the blockchain from existing peers. Once this has\ncompleted, it can send new transactions just as any other peer.")])])]),e._v(" "),n("h3",{attrs:{id:"ibft-clique"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ibft-clique","aria-hidden":"true"}},[e._v("↳")]),e._v(" IBFT/Clique")]),e._v(" "),n("p",[e._v("Adding nodes to an IBFT/Clique network is a bit simpler, as it only needs to configure itself rather then be\npre-allocated on the network (permissioning aside).")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("Initialise the new node with the network's genesis configuration.")]),e._v(" "),n("p",[e._v("!!! note\nWhere you obtain this from will be dependent on the network. You may get it from an existing peer, or a network operator, or elsewhere entirely.")]),e._v(" "),n("p",[e._v("Initialising the new node is exactly the same an the original nodes.")]),e._v(" "),n("div",{staticClass:"language-bash extra-class"},[n("pre",{pre:!0,attrs:{class:"language-bash"}},[n("code",[e._v("$ geth --datadir qdata/dd7 init genesis.json\n")])])])]),e._v(" "),n("li",[n("p",[e._v("If you are using permissioning or discovery for Ethereum peer-to-peer, please refer "),n("a",{attrs:{href:"#extra-options"}},[e._v("here")]),e._v(".")])]),e._v(" "),n("li",[n("p",[e._v("Start the new node, pointing either to a "),n("code",[e._v("bootnode")]),e._v(" or listing an existing peer in the "),n("code",[e._v("static-nodes.json")]),e._v(" file.\nOnce a connection is established, the node will start syncing the blockchain, after which transactions can be sent.")])])]),e._v(" "),n("h3",{attrs:{id:"extra-options"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#extra-options","aria-hidden":"true"}},[e._v("↳")]),e._v(" Extra options")]),e._v(" "),n("p",[e._v("Some options take effect regardless of the consensus mechanism used.")]),e._v(" "),n("h4",{attrs:{id:"permissioned-nodes"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#permissioned-nodes","aria-hidden":"true"}},[e._v("↳")]),e._v(" Permissioned nodes")]),e._v(" "),n("p",[e._v("If using the "),n("code",[e._v("permissioned-nodes.json")]),e._v(" file for permissioning, then you must make sure this file is updated on all\nnodes before the new node is able to communicate with existing nodes. You do not need to restart any nodes in\norder for the changes to take effect.")]),e._v(" "),n("h4",{attrs:{id:"static-node-connections"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#static-node-connections","aria-hidden":"true"}},[e._v("↳")]),e._v(" Static node connections")]),e._v(" "),n("p",[e._v("If not using peer-to-peer node discovery (i.e. you have specified "),n("code",[e._v("--nodiscover")]),e._v("), then the only connections a node\nmade will be to peers defined in the "),n("code",[e._v("static-nodes.json")]),e._v(" file. When adding a new node, you should make sure you have\npeers defined in its "),n("code",[e._v("static-nodes.json")]),e._v(" file. The more peers you have defined here, the better network connectivity\nand fault tolerance you have.")]),e._v(" "),n("p",[e._v("!!! note\n* You do not need to update the existing peers static nodes for the connection to be established, although it is good practise to do so.\n* You do not need to specify every peer in your static nodes file if you do not wish to connect to every peer directly.")]),e._v(" "),n("h4",{attrs:{id:"peer-to-peer-discovery"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#peer-to-peer-discovery","aria-hidden":"true"}},[e._v("↳")]),e._v(" Peer-to-peer discovery")]),e._v(" "),n("p",[e._v("If you are using discovery, then more options "),n("em",[e._v("in addition")]),e._v(" to static nodes become available.")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("Any nodes that are connected to your peers, which at the start will be ones defined in the static node list, will\nthen be visible by you, allowing you to connect to them; this is done automatically.")])]),e._v(" "),n("li",[n("p",[e._v("You may specify any number of bootnodes, defined by the "),n("code",[e._v("--bootnodes")]),e._v(" parameter. This takes a commas separated list\nof enode URIs, similar to the "),n("code",[e._v("static-nodes.json")]),e._v(" file. These act in the same way as static nodes, letting you connect\nto them and then find out about other peers, whom you then connect to.")])])]),e._v(" "),n("p",[e._v("!!! note\nIf you have discovery disabled, this means you will not try to find other nodes to connect to, but others can still find and connect to you.")]),e._v(" "),n("h2",{attrs:{id:"adding-private-transaction-managers"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#adding-private-transaction-managers","aria-hidden":"true"}},[e._v("↳")]),e._v(" Adding Private Transaction Managers")]),e._v(" "),n("p",[e._v("In this tutorial, there will be no focus on the advanced features of adding a new Private Transaction Manager (PTM).\nThis tutorial uses "),n("a",{attrs:{href:"https://github.com/smilofoundation/tessera",target:"_blank",rel:"noopener noreferrer"}},[e._v("Tessera"),n("OutboundLink")],1),e._v(" for any examples.")]),e._v(" "),n("p",[e._v("Adding a new node to the PTM is relatively straight forward, but there are a lot of extra options that can be used,\nwhich is what will be explained here.")]),e._v(" "),n("h3",{attrs:{id:"adding-a-new-ptm-node"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#adding-a-new-ptm-node","aria-hidden":"true"}},[e._v("↳")]),e._v(" Adding a new PTM node")]),e._v(" "),n("p",[e._v("In a basic setting, adding a new PTM node is as simple as making sure you have one of the existing nodes listed in your\npeer list.")]),e._v(" "),n("p",[e._v("In Tessera, this would equate to the following in the configuration file:")]),e._v(" "),n("div",{staticClass:"language-json extra-class"},[n("pre",{pre:!0,attrs:{class:"language-json"}},[n("code",[n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token property"}},[e._v('"peers"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n      "),n("span",{pre:!0,attrs:{class:"token property"}},[e._v('"url"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[e._v('"http://existingpeer1.com:8080"')]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),n("p",[e._v("From there, Tessera will connect to that peer and discover all the other PTM nodes in the network, connecting to each\nof them in turn.")]),e._v(" "),n("p",[e._v("!!! note\nYou may want to include multiple peers in the peer list in case any of them are offline/unreachable.")]),e._v(" "),n("h3",{attrs:{id:"ip-whitelisting"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ip-whitelisting","aria-hidden":"true"}},[e._v("↳")]),e._v(" IP whitelisting")]),e._v(" "),n("p",[e._v("The IP Whitelist that Tessera provides allows you restrict connections much like the "),n("code",[e._v("permissioned-nodes.json")]),e._v(" file\ndoes for Smilo. Only IP addresses/hostnames listed in your peers list will be allowed to connect to you.")]),e._v(" "),n("p",[e._v("See the "),n("a",{attrs:{href:"/Privacy/Tessera/Configuration/Configuration%20Overview#whitelist"}},[e._v("Tessera configuration page")]),e._v(" for details on setting it up.")]),e._v(" "),n("p",[e._v("In order to make sure the new node is accepted into the network:")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("You will need to add the new peer to each of the existing nodes before communication is allowed.\nTessera provides a way to do this without needing to restart an already running node:")]),e._v(" "),n("div",{staticClass:"language-bash extra-class"},[n("pre",{pre:!0,attrs:{class:"language-bash"}},[n("code",[e._v("$ java -jar tessera.jar admin -configfile /path/to/existing-node-config.json -addpeer http://newpeer.com:8080\n")])])])]),e._v(" "),n("li",[n("p",[e._v("The new peer can be started, setting the "),n("code",[e._v("peers")]),e._v(" configuration to mirror the existing network.\ne.g. if there are 3 existing nodes in the network, then the new nodes configuration will look like this:")]),e._v(" "),n("div",{staticClass:"language-json extra-class"},[n("pre",{pre:!0,attrs:{class:"language-json"}},[n("code",[n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token property"}},[e._v('"peers"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n      "),n("span",{pre:!0,attrs:{class:"token property"}},[e._v('"url"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[e._v('"http://existingpeer1.com:8080"')]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n      "),n("span",{pre:!0,attrs:{class:"token property"}},[e._v('"url"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[e._v('"http://existingpeer2.com:8080"')]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n      "),n("span",{pre:!0,attrs:{class:"token property"}},[e._v('"url"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[e._v('"http://existingpeer3.com:8080"')]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),n("p",[e._v("The new node will allow incoming connections from the existing peers, and then existing peers will allow incoming\nconnections from the new peer!")])])]),e._v(" "),n("h3",{attrs:{id:"discovery"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#discovery","aria-hidden":"true"}},[e._v("↳")]),e._v(" Discovery")]),e._v(" "),n("p",[e._v("Tessera discovery is very similar to the IP whitelist. The difference being that the IP whitelist blocks\ncommunications between nodes, whereas disabling discovery only affects which public keys we keep track of.")]),e._v(" "),n("p",[e._v("See the "),n("a",{attrs:{href:"/Privacy/Tessera/Configuration/Configuration%20Overview#disabling-peer-discovery"}},[e._v("Tessera configuration page")]),e._v(" for\ndetails on setting it up.")]),e._v(" "),n("p",[e._v("When discovery is disabled, Tessera will only allow keys that are owned by a node in its peer list to be available to\nthe users. This means that if any keys are found that are owned by a node NOT in our peer list, they are discarded and\nprivate transactions cannot be sent to that public key.")]),e._v(" "),n("p",[e._v("!!! note\nThis does not affect incoming transactions. Someone not in your peer list can still send transactions to your node, unless you also enable the IP Whitelist option.")]),e._v(" "),n("p",[e._v("In order to make sure the new node is accepted into the network:")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("You will need to add the new peer to each of the existing nodes before they will accept public keys that are linked\nto the new peer.\nTessera provides a way to do this without needing to restart an already running node:")]),e._v(" "),n("div",{staticClass:"language-bash extra-class"},[n("pre",{pre:!0,attrs:{class:"language-bash"}},[n("code",[e._v("$ java -jar tessera.jar admin -configfile /path/to/existing-node-config.json -addpeer http://newpeer.com:8080\n")])])])]),e._v(" "),n("li",[n("p",[e._v("The new peer can be started, setting the "),n("code",[e._v("peers")]),e._v(" configuration to mirror the existing network.\ne.g. if there are 3 existing nodes in the network, then the new nodes configuration will look like this:")]),e._v(" "),n("div",{staticClass:"language-json extra-class"},[n("pre",{pre:!0,attrs:{class:"language-json"}},[n("code",[n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token property"}},[e._v('"peers"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n      "),n("span",{pre:!0,attrs:{class:"token property"}},[e._v('"url"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[e._v('"http://existingpeer1.com:8080"')]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n      "),n("span",{pre:!0,attrs:{class:"token property"}},[e._v('"url"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[e._v('"http://existingpeer2.com:8080"')]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n      "),n("span",{pre:!0,attrs:{class:"token property"}},[e._v('"url"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[e._v('"http://existingpeer3.com:8080"')]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),n("p",[e._v("The new node will now record public keys belonging to the existing peers, and then existing peers will record\npublic keys belonging to the new peer; this allows private transactions to be sent both directions!")])])]),e._v(" "),n("h2",{attrs:{id:"examples"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#examples","aria-hidden":"true"}},[e._v("↳")]),e._v(" Examples")]),e._v(" "),n("p",[e._v("For a walkthrough of some examples that put into action the above, check out "),n("a",{attrs:{href:"/How-To-Guides/add_node_examples"}},[e._v("this guide")]),e._v("!")])])}),[],!1,null,null,null);t.default=s.exports}}]);